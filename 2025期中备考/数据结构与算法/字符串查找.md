## KMP算法和BM算法
### 一.KMP算法是基于已知的状态来建立自动机，实现利用已匹配的信息。
 -  优点：KMP算法可以通过前后缀的相同来达到快速跳转的实现
- 缺点：从前端向后遍历，跳转速率过慢。
- 构建重心：dfa或者next数组(简化后的dfa)。
#####  代码实现(c语言)
```C
#include <stdio.h>
#include <string.h>

// 计算next数组
void compute_next(const char* pattern,int next[]) 
{
    int len = strlen(pattern);
    next[0] = -1;
    int k = -1;//记录上一个next数组的值，实现递归
    int i = 0;
    while(i < len-1){
        if(k== -1 || pattern[i] == pattern[k]){
        next[++i] = ++k;
        }else{   
        k = next[k];
        }
    }   
}
int KMP(const char* source,const char* pattern,int next[])
{
    int lenS = strlen(source);
    int lenP = strlen(pattern);
    int i  = 0;
    int j = 0;
    while(i < lenS){
        if(pattern[j] == source[i]){
            if(j < lenP-1){
            i++;
            j++;
            }
            else
            return i-j;
        }else{
            j = next[j];
            if(j == -1){
            i++;
            j=0;
            }
        }
    }
    return -1;
}
int main(void)
{
    printf("请输入源字符串长度\n");
    int lenS;
    scanf("%d",&lenS);
    char s[lenS];
    printf("请输入源字符串\n");
    scanf("%s",s);//s本身就是地址
    printf("请输入模式串长度\n");
    int lenP;
    scanf("%d",&lenP);
    printf("请输入模式串\n");
    char p[lenP];
    scanf("%s",p);
    int next[lenP];
    compute_next(p,next);
    int index = KMP(s,p,next);
    if(index != -1)
    printf("索引为%d",index);
    else
    printf("未找到");


}
```


### 二.BM算法
- 优点：从后向前比较，运用坏字符和好后缀原则，大幅提升跳转速度。
- 缺点：好后缀原则较难理解。
