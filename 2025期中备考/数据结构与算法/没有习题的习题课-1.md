软件是程序以及开发、使用和维护程序所需要的各种文档。

## 什么是数据结构

**数据结构**：研究非数值计算程序设计问题中计算机的操作对象及它们之间关系和操作的学科。

**事例**：仓库存量管理、学生成绩管理、家谱管理、地图管理

### 数据结构的研究内容
- 数据之间的**逻辑关系**，以及这种关系对应的操作
- 如何存储某种逻辑关系（**存储实现**）
- 在这种存储模式下，关系的操作是如何实现的（**运算实现**）

## 数据的逻辑结构

1. **集合结构**：元素间的次序是任意的。元素之间除了"属于同一集合"的联系外没有其他的关系。
2. **线性结构**：数据元素的有序序列。除了第一个和最后一个元素外，其余元素都有一个前趋和一个后继。
3. **树形结构**：除了根元素外，每个节点有且仅有一个前趋，后继数目不限。
4. **图型结构**：每个元素的前趋和后继数目都不限。

数据的逻辑结构与数据元素本身的内容无关，与数据元素的个数无关。

## 数据结构的操作

- **创建**：创建一个数据结构
- **清除**：删除数据结构
- **插入**：在数据结构指定的位置上插入一个新元素
- **删除**：将数据结构中的某个元素删去
- **搜索**：在数据结构中搜索满足特定条件的元素
- **更新**：修改数据结构中的某个元素的值
- **访问**：访问数据结构中的某个元素
- **遍历**：按照某种次序访问数据结构中的每一元素，使每个元素恰好被访问一次

每一种数据结构的特定操作。

## 数据结构的存储实现（物理结构）

物理结构由三个部分组成：
1. **存储结点**：每个存储结点存放一个数据元素
2. **数据元素之间的关系**的存储：逻辑结构的机内表示
3. **附加信息**：便于运算实现而设置的一些"哑结点"，如链表中的头结点

### 关系的存储

1. **顺序存储**：用存储的位置表示元素之间的关系。主要用数组实现。
2. **链接存储**：用指针显式地指出元素之间的关系，如单链表就是表示线性关系的。
3. **哈希存储方式**：专用于集合结构的数据存放方式。在哈希存储中，各个结点均匀地分布在一块连续的存储区域中，用一个哈希函数将数据元素和存储位置关联起来。
4. **索引存储方式**：所有的存储结点按照生成的次序连续存放。另外设置一个索引区域表示结点之间的关系。

## 数据结构的描述和实现

- **数据结构的逻辑特性**：每种数据结构用一个抽象数据类型描述，指出该数据结构提供的操作。
- **数据结构的实现**：每种数据结构可以有若干种实现的方法，数据结构基础操作的实现与其存储结构密切相关。每种实现都要实现数据结构的逻辑特性。

## 什么是算法？

**算法(algorithm)**：一个（由人或机器进行）关于某种运算规则的集合。

**特点**：
- 执行时，不能包含任何主观的决定
- 不能有类似直觉/创造力等因素
- 确定性：清晰、无歧义
- 有限性：指令执行次数、时间

**程序**：用某种程序设计语言描述，其指令必须是机器可执行的，不一定满足有穷性。

**算法**：用自然语言、流程图、程序设计语言或伪代码描述，侧重于对问题的解。

### 〖Example〗 Selection Sort

Sort a set of n ≥ 1 integers in increasing order.

From those integers that are currently unsorted, find the smallest and place it next in the sorted list.

## 算法与程序

## 算法分析

数据结构是讨论一组数据的处理问题。每一种存储方式下对应的每一种操作的实现都是一个算法。每种操作有多种实现方式。

**如何评价这些算法的好坏？**

Primary practical reason: avoid performance bugs.

### 算法的质量评价

1. **正确性**：算法应能正确地实现预定的功能
2. **易读性**：算法应易于阅读和理解，以便于调试、修改和扩充
3. **健壮性**：当环境发生变化（如遇到非法输入）时，算法能适当地做出反应或进行处理，不会产生不正确的运算结果
4. **高效率**：具有较高的时间和空间性能

这四个指标往往是互相冲突的，数据结构主要考虑的是**算法效率**。

### 算法效率分析

- **时间**：程序运行所需要的时间。要运行一年的算法是很难让人接受的。
- **空间**：程序运行所需要的空间。需要几个G的内存的算法同样也令人难以接受。

### 算法分析内容

1. 时间复杂度的概念
2. 算法运算量的计算
3. 渐进表示法
4. 时间复杂度的计算
5. 算法的优化
6. 空间复杂度的概念

## 程序的运行时间

**影响运行时间的因素**：
- 问题规模和输入数据的分布
- 编译器生成的目标代码的质量
- 计算机系统的性能
- 程序采用的算法的优劣

### 时间复杂度

算法的时间复杂度是一种抽象的度量，即运算量与问题规模之间的关系。算法的时间复杂度也与被处理的数据分布有关。

**算法的时间复杂度**：
- **最好情况的时间复杂度**：Lower bound on cost
- **最坏情况的时间复杂度**：Upper bound on cost
- **平均情况的时间复杂度**："Expected" cost

## 算法运算量的计算

1. 根据问题的特点合理地选择一种或几种操作作为"标准操作"，将标准操作作为一个抽象的运算单位
2. 确定每个算法在给定的输入下共执行了多少次标准操作，并将它作为算法的计算量

### 〖Example〗 Iterative function for summing a list of numbers

```c
T_sum(n) = 2n + 3
```

### 〖Example〗 Recursive function for summing a list of numbers

```c
T_rsum(n) = 2n + 2
```

But it takes more time to compute each step.

## 渐进表示法

算法的运行时间函数可能是一个很复杂的函数，如何比较这些函数并从中选取出一个好的算法呢？时间性能主要考虑的是问题规模很大的时候运行时间随问题规模的变化规律。

**渐进表示法**：不考虑具体的运行时间函数，只考虑运行时间函数的**数量级**。

### 大O表示法实例

如果存在正的常数c和N₀，满足当N>=N₀时有T(N) ≤ cF(N)，则T(N)=O(F(N))。

设 T(n) = n+1, F(n)=n  
那么，取N₀ = 1及c=2时，T(n) ≤ cF(n)成立。  
所以，T(n) = O(n)

T(N)的增长率小于或等于F(N)的增长率。

### 渐进表示法—定理

**定理1**：If T(n)=aₖnᵏ+aₖ₋₁nᵏ⁻¹+…+a₁n+a₀, then T(n)=O(nᵏ)

**定理2**：for every k≥1, nᵏ is not O(nᵏ⁻¹)

**定理3**：O(2ⁿ⁺¹⁰)=O(2ⁿ)

**定理4**：O(2¹⁰ⁿ)≠O(2ⁿ)

**定理5（求和定理）**：for f(n), g(n), max(f, g)=O(f(n)+g(n))

**定理6（求积定理）**：for f(n), g(n), f×g=O(f(n) × g(n))

### F(N)的选择

渐进表示法并不需要给出运行时间的精确值，而只需要给出一个数量级，表示当问题规模很大时算法运行时间的增长是受限于哪一个数量级的函数。在选择F(N)时，通常选择的是比较简单的函数形式，并**忽略低次项和系数**。

### 典型的增长率

- c：常量
- logN：对数
- Log²N：对数的平方
- N：线性
- NlogN：NlogN
- N²：平方
- N³：立方
- 2ⁿ：指数

### 算法按时间复杂度分类

**多项式时间复杂度的关系**：  
O(1) < O(logN) < O(N) < O(NlogN) < O(N²) < O(N³)

**指数时间复杂度的关系**：  
O(2ⁿ) < O(N!) < O(Nⁿ)

Note: 2ⁿ + 3 = O(N) = O(N²) = O(2ⁿ) = … We shall always take the smallest f(N).

## 大O表示法的计算规则

**规则1**：每个简单语句，如赋值语句、输入输出语句，它们的运行时间与问题规模无关，在每个计算机系统中运行时间都是一个常量，因此时间复杂度为O(1)。

**规则2**：条件语句，if <条件> then <语句> else <语句>的运行时间为执行条件判断的代价，一般为O(1)，再加上执行then后面的语句的代价（若条件为真），或执行else后面的语句代价（若条件为假）之和，即max(O(then子句)，O(else子句))。

**规则3**：循环语句的执行时间是循环控制行和循环体执行时间的总和。循环控制一般是一个简单的条件判断，因此循环语句的执行时间是**循环体的运行时间乘循环次数**。

**规则4**：嵌套循环语句，对外层循环的每个循环周期，内存循环都要执行它的所有循环周期，因此，可用求积定理计算整个循环的时间复杂度，即**最内层循环体的运行时间乘所有循环的循环次数**。

例语句：`for (i=0; i<n; i++) for (j=0; j<n; j++) k++;`的时间复杂性为O(n²)

**连续语句**：利用求和定理把这些语句的时间复杂性相加。

例：
```c
for (i=0; i<n; i++) a[i]=0;
for (i=0; i<n; i++)
    for (j=0; j<n; j++) a[i]= i+j;
```
该程序段有两个连续的循环组成。第一个循环的时间复杂度为O(n)，第二个循环的时间复杂度为O(n²)。根据求和定理，整段程序的的时间复杂性为O(n²)。

### 大O的简化计算

在程序中找出==最复杂、运行时间最长==的程序段，计算它的时间复杂度。也就是整个程序的时间复杂度。

## 典型实例--最大连续子序列问题

给定（可能是负的）整数序列A₁，A₂，A₃… A_N，寻找（并标识）的值为最大的序列。如果所有的整数都是负的，那么最大连续子序列的和是零。

例如：
- {-2, 11, -4, 13, -5, 2} → 和为20
- {1, -3, 4, -2, -1, 6} → 和为7

### 解法一：穷举法(brute-force algorithm)

分别求以下子序列的和，求出最大值：
[0,0], [0,1], [0,1,2], …, [0,1,2,…,n]
[1,1], [1,2], …, [1,2,…,n]
…
[n,n]

**Algorithm 1**
```c
int MaxSubsequenceSum(const int A[], int N) {
    int ThisSum, MaxSum, i, j, k;
    MaxSum = 0;
    for (i = 0; i < N; i++)
        for (j = i; j < N; j++) {
            ThisSum = 0;
            for (k = i; k <= j; k++)
                ThisSum += A[k];
            if (ThisSum > MaxSum)
                MaxSum = ThisSum;
        }
    return MaxSum;
}
```
T(N) = O(N³) 三层for循环

### 时间复杂度分析

最里层的语句`ThisSum += a[k];`在最里层循环中执行j-i+1次。第二个循环的规模是n-i，最外层的循坏规模是n。因此最里层语句执行的次数是…

### 方法二：O(n²)的算法

由于…，因此，方法一中最里层的循环可以省略。

**Algorithm 2**
```c
int MaxSubsequenceSum(const int A[], int N) {
    int ThisSum, MaxSum, i, j;
    MaxSum = 0;
    for (i = 0; i < N; i++) {
        ThisSum = 0;
        for (j = i; j < N; j++) {
            ThisSum += A[j];
            if (ThisSum > MaxSum)
                MaxSum = ThisSum;
        }
    }
    return MaxSum;
}
```
T(N) = O(N²)

### 方法三：分治法（Divide and Conquer Algorithm）

采用分治（Divide and Conquer）策略。
- **分（Divide）**：将问题分成两个大致相等的子问题，然后对它们递归求解。
- **治（Conquer）**：将两个子问题的解合并。

例：
- 递归地计算整个位于前半部的最大连续子序列。
- 递归地计算整个位于后半部的最大连续子序列。
- 通过两个连续循环，计算从前半部开始但在后半部结束的最大连续子序列的和。
- 选择三个和中的最大值。

```c
int maxSum(int a[], int left, int right) {
    int maxLeft, maxRight, center;
    int leftSum = 0, rightSum = 0;
    int maxLeftTmp = NEGMAX;
    int maxRightTmp = NEGMAX;
    
    center = (left + right) / 2;
    if (left == right) return a[left] > 0 ? a[left] : 0;
    
    maxLeft = maxSum(a, left, center);
    maxRight = maxSum(a, center + 1, right);
    
    for (int i = center; i >= left; --i) {
        leftSum += a[i];
        if (leftSum > maxLeftTmp) maxLeftTmp = leftSum;
    }
    
    for (int i = center + 1; i <= right; ++i) {
        rightSum += a[i];
        if (rightSum > maxRightTmp) maxRightTmp = rightSum;
    }
    return max3(maxLeft, maxRight, maxLeftTmp + maxRightTmp);
}
```

**时间复杂度分析**
T(N) = 2T(N/2) + cN, T(1) = O(1)
= 2[2T(N/2²) + cN/2] + cN
= 2ᵏO(1) + ckN where N/2ᵏ = 1
= O(NlogN)

Also true for N ≠ 2ᵏ

### 方法四：O(N)
贪心算法，每次只选择局部最优解

如果一个子序列的和是负的，则它不可能是最大连续子序列的一部分，因为我们可以通过不包含它来得到一个更大的连续子序列。

如：{-2, 11, -4, 13, -5, 2}的最大子序列不可能从-2开始  
{1, -3, 4, -2, -1, 6}的最大子序列不可能包含{1,-3}

所有与最大连续子序列毗邻的连续子序列一定有负的（或0）和（否则会包含它们）。

在算法二中，当检测出一个负的子序列时，不但可以从内层循环中跳出来，而且还可以让i直接增加到j+1。

如：{1, -3, 4, -2, -1, 6}，当检测序列[1,-3]后，发现是负值，则表示该子序列不可能包含在最大子序列中。因此，接下去就可以从4开始检测。

**Algorithm 4 On-line Algorithm**
```c
int MaxSubsequenceSum(const int A[], int N) {
    int ThisSum, MaxSum, j;
    ThisSum = MaxSum = 0;
    for (j = 0; j < N; j++) {
        ThisSum += A[j];
        if (ThisSum > MaxSum)
            MaxSum = ThisSum;
        else if (ThisSum < 0)
            ThisSum = 0;
    }
    return MaxSum;
}
```
T(N) = O(N)

A[] is scanned once only.

At any point in time, the algorithm can correctly give an answer to the subsequence problem for the data it has already read.

Note: The time required to read the input is not included.

### 优化算法

- **Upper bound**：A specific algorithm. Running time of the optimal algorithm is O(N).
- **Lower bound**：no algorithm can do better. Running time of the optimal algorithm is Ω(N).
- **Optimal algorithm**：Performance guarantee (to within a constant factor) for any input.
- Lower bound equals upper bound (to within a constant factor). No algorithm can provide a better performance guarantee.

## 算法的空间复杂度

- **固定空间需求**：与处理的问题规模无关
- **可变空间需求**：与处理的数据量有关
- **渐进的空间复杂度**：当n→∞占用的空间量与n的关系
- 空间复杂度一般按最坏情况处理
- 空间复杂度的计算比较简单，表示方法与时间复杂度相同

### Typical memory usage for primitive types and arrays

64-bit machine: with 8 byte pointers

## 总结

- 数据结构研究非数值计算问题中数据之间的逻辑结构、物理结构及其运算
- 算法的确定比程序设计技巧对程序运行时间的影响更大
- 大O分析是一种很有效的工具，但它也有局限性。如前所述，它的使用不适合输入规模较小的场合。此时，最高项的系数或低次项对运行时间的影响较大

# 第一部分 线性结构

具有线性关系的数据集合的处理。

## 常见的几种线性结构

1. **位置有序表——线性表(Lists)**：由节点间的相互位置决定其线性关系（顺序结构、链式结构）
2. **时间有序表（Chronological Ordered List）——栈(Stacks)、队列(Queues)**：由节点到达的先后顺序决定其线性关系
3. **排序表（Sorted Lists）**
4. **频率有序表（Frequency Ordered List）**

### 线性结构内容
- 线性表(Lists)
- 栈(Stacks)
- 队列(Queues)
- 串
- 数组和广义表

## 线性表

### 线性表的概念

线性表是N个具有相同特征的结点a₀, a₁, …, a_N₋₁构成的集合。在这个集合中，除了a₀和a_N₋₁外，每个元素都有唯一的前趋和后继。对于每个aᵢ，它的前驱是aᵢ₋₁，它的后继是aᵢ₊₁。a₀只有后继没有前驱，a_N₋₁只有前驱没有后继。

**表的术语**：
- N为表的大小
- a₀称为首结点，a_N₋₁称为尾结点
- 空表：元素个数为零的表
- 位置：元素aᵢ在表中的位置为i

### 表的基本操作

- **create()**：创建一个空的线性表
- **clear()**：删除线性表中的所有数据元素
- **length()**：返回线性表的长度
- **insert(i, x)**：在第i个位置插入一个元素，使线性表从（a₀, a₁, …aᵢ₋₁, aᵢ, …a_n₋₁）变成（a₀, a₁, …aᵢ₋₁, x, aᵢ, …a_n₋₁），参数i的合法取值范围是0到n
- **remove(i)**：删除第i个位置的元素，使线性表从（a₀, a₁, …aᵢ₋₁, aᵢ, aᵢ₊₁, …a_n₋₁）变成（a₀, a₁, …aᵢ₋₁, aᵢ₊₁, …a_n₋₁），参数i的合法取值范围是0到n-1
- **search(x)**：在线性表中搜索x是否出现，并返回x的位置
- **visit(i)**：返回线性表中第i个数据元素的值
- **traverse()**：按序访问线性表的每一数据元素

### 线性表的顺序存储结构

线性表中结点存放在存储器上一块连续的空间中。借助存储空间的连续性，结点可以按照其逻辑顺序依次存放。结点存放的物理位置和它的逻辑位置是一致的。

线性表的顺序实现通常称为**顺序表**。

**实现**：动态数组

**参数**：指向线性表元素类型的指针(data)，数组规模或容量(maxSize)，数组中的元素个数或表长(length)。

线性表必须支持插入或删除，**申请空间一般要比实际元素个数多一点**。

### 线性表的运算实现

- **length()**：只需要返回length的值
- **visit(i)**：返回data[i]的值
- **traverse()**：输出数组data的前length个元素
- **clear()**：只要将length置为0即可
- **create(maxSize)**：申请一个maxSize大小的动态数组
- **search(x)**
- **resize**
- **insert(i, x)**
- **remove(i)**

#### search运算的实现
```c
int search(x) {
    for (num = 0; num < length; ++num)
        if (data[num] == x) break;
    if (num == length) num = -1;
    return num;
}
```

#### resize操作的实现

resize操作按一定的比例扩大数组的空间，常用的比例是扩大一倍。扩大数组空间的操作必须：
1. 重新申请一个更大规模的动态数组
2. 将原有数组的内容拷贝到新数组中
3. 释放原有数组空间

#### insert(i, x)运算的实现
```c
void insert(i, x) {
    if (length == maxSize) resize();
    for (j = n-1; j>=i; --j) data[j+1] = data[j];
    data[i] = x;
    ++length;
}
```

#### remove(i)运算的实现
```c
void remove(i) {
    for (j = i; j < length - 1; ++j)
        data[j] = data[j+1];
    --length;
}
```

### 顺序实现的算法分析

- **length, visit和clear**的实现与表中的元素个数无关，因此它们的时间复杂度是O(1)
- **traverse()**操作遍历整个表中的所有元素，因此时间复杂度为O(n)
- **create**操作需要申请一块动态数组的空间，并设表为空。因此也是O(1)的时间复杂度
- **插入、删除操作**，需要移动结点。当i等于n时，移动次数为0。当i等于0时，移动次数为n
- 最好情况下的时间复杂度为O(1)
- 最坏情况下的时间复杂度为O(n)
- 平均的时间复杂度：如果在每个位置上的插入都是等概率的，则插入算法的平均时间复杂度为…

### 线性表的顺序实现总结

- 需预估数组的最大空间。比较适合静态的、经常做定位访问的线性表
- 由于逻辑次序和物理次序的一致性使得定位访问的性能很好
- 由于要保持逻辑次序和物理次序的一致性，顺序表在插入删除时需要移动大量的数据，性能不太理想

## 线性表的链接存储结构

将每个结点放在一个独立的存储单元中，结点间的逻辑关系依靠存储单元中附加的值针来给出。结点的存储单元在物理位置上可以相邻，也可以不相邻。

**分类**：
- 单链表
- 双链表
- 循环链表

### 单链表

**Initialization**:
```c
typedef struct list_node *list_ptr;
typedef struct list_node {
    char data[4];
    list_ptr next;
};
list_ptr ptr;
```

每个结点附加了一个指针字段，如next，该指针指向它的直接后继结点，最后一个结点的next字段为空。

#### Insertion
1. temp->next = node->next
2. node->next = temp

Question: What will happen if the order of the two steps is reversed?  
Question: How can we insert a new first item?  
Takes O(1) time.

#### Deletion
1. pre->next = node->next
2. free(node)

Question: How can we delete the first node from a list?  
Answer: We can add a dummy head node to a list.  
Takes O(1) time.

### 头结点、头指针

**头结点**：在表头额外增加的一个相同类型的特殊结点。它们不是线性表中的组成部分。头结点的出现，使得在表头位置上进行插入和删除和在其它结点位置上是完全一致的。

#### Create函数的实现

建立一个空表：申请一块存储结点的空间，设结点的指针部分为空指针。将结点地址存入代表单链表的变量head。

#### clear()：清除一个线性表

把所有结点的空间还给系统，把头结点的指针部分置为空指针
```c
void clear() {
    p = 头结点的直接后继;
    while (p != ∧) {
        q = p;
        p = p的直接后继地址;
        释放q所指结点空间;
    }
    头结点的后继指针 = ∧;
}
```

#### length()：求表的长度

**方法1**：从起始结点开始，沿着后继指针链一个一个往后数，数到一个结点，长度加1
```c
int length() {
    len = 0;
    p = 头结点的直接后继；
    while (p != ∧) {
        ++len;
        p = p的直接后继的地址；
    }
}
```

**方法2**：用空间换取时间的方法。在保存单链表的时候增加一个变量，保存表的长度

#### insert(i, x): 在第i个位置插入一个元素
```c
void insert(i, x) {
    for (j = 0, p = head; j < i; ++j)
        p = p的直接后继的地址；
    tmp = new 结点；
    tmp指向的结点的数据部分 = x；
    tmp指向的结点的指针部分 = p的直接后继的地址；
    p指向的结点的指针部分 = tmp；
}
```

#### Remove(i): 删除第i个位置的元素
```c
void remove(i) {
    for (j = 0, p = head; j < i; ++j)
        p = p的直接后继的地址；
    tmp = p的直接后继的地址；
    p的指针部分 = tmp的直接后继的地址；
    free tmp；
}
```

#### search(x): 搜索x在线性表中是否出现
```c
int search(x) {
    num = 0;
    p = 头结点的直接后继；
    while (p != 空指针 && p的数据部分 != x) {
        ++num;
        p = p的直接后继的地址；
    }
    if (p == 空指针) num = -1；
    return num;
}
```

#### Visit(i): 访问线性表的第i个元素
```c
dataType visit(i) {
    for (j = 0, p = head; j < i; ++j)
        p = p的直接后继的地址；
    return p指向的结点的数据部分；
}
```

#### traverse(): 遍历运算
```c
void traverse() {
    p = 头结点的直接后继；
    while (p != 空指针) {
        cout << p指向结点的数据部分；
        p = p的直接后继的地址；
    }
}
```

### 双链表

**双链表**：每个结点附加了两个指针字段，如prior和next。prior字段给出直接前驱结点的地址，next给出直接后继结点的地址。

ptr = ptr->prior->next = ptr->next->prior

#### 双链表的头尾节点

为了消除在表头、表尾插入删除的特殊情况，通常双链表设一头结点，设一尾节点：
- 头结点中prior字段为空，它的next字段给出线性表中的首结点的地址
- 尾结点中next字段为空，它的prior字段给出线性表中最后一个节点的地址

#### create

创建一个双链表就是创建一个只有头尾结点的链表，把头结点的地址保存在head中，尾结点的地址保存在tail中：
```c
head->prior = ∧
head->next = tail
tail->prior = head
tail->next = ∧
```

#### insert
```c
p->prev->next = tmp
temp->prior = p->prior
temp->next = p
p->prev = tmp
```

#### remove
```c
p->prev->next = pos->next
p->next->prev = p->prev
delete p
```

### 单循环链表

最后一个结点指向头结点

### 双循环链表

头结点中prior字段给出尾结点的地址，尾结点中next字段给出头结点的地址

## 总结

- 线性表是最常见、最简单的数据结构
- 两种最典型的实现方式：顺序表、链接表
- 基本运算及其算法
- 线性表的应用：灵活应用、举一反三

# 栈

## 栈的概念

**后进先出(LIFO, Last In First Out)**  
**先进后出(FILO, First In Last Out)**  
最先（晚）到达栈的结点将最晚（先）被删除

例：集装箱吊装

### 栈的相关概念

- **栈底(bottom)**：结构的首部（结点最早到达的部分）
- **栈顶（top）**：结构的尾部（结点最晚到达的部分）
- **出栈（Pop）**：结点从栈顶删除
- **进栈（Push）**：结点在栈顶位置插入
- **空栈**：栈中结点个数为零

### 栈的运算

- **create()**：创建一个空的栈
- **push(x)**：将x插入栈中，使之成为栈顶元素
- **pop()**：删除栈顶元素并返回栈顶元素值
- **top()**：返回栈顶元素值但不删除栈顶元素
- **isEmpty()**：若栈为空，返回true，否则返回false

## 栈的顺序实现

用连续的空间（即数组）存储栈中的结点。进栈和出栈总是在栈顶一端进行，不会引起类似顺序表中的大量数据的移动。用数组的后端表示栈顶。

### 顺序实现性能分析

- 除了进栈操作以外，所有运算实现的时间复杂度都是O（1）
- 进栈运算在最坏情况下（数组满）的时间复杂度是O（N）
- 但最坏情况在N次进栈操作中至多出现一次。如果把扩展数组规模所需的时间均摊到每个插入操作，每个插入只多了一个拷贝操作，因此从平均的意义上讲，插入运算还是常量的时间复杂度。这种分析方法称为均摊分析法
- 没有考虑数组的收缩问题

### 共享栈

**问题**：在实际应用中需要同时使用多个栈。每个栈按最大可能来分配需要大量空间。栈的内容呈动态变化特征。

是否可在同一连续空间中设计多个栈，实现空间共享？

#### 共享栈图示

在一个数组中实现四个栈

## 栈的链接实现

用单链表即可，且不需要头结点。将单链表的头指针指向栈顶。

```c
void push(const elemType &x) {
    node *tmp = new node(x, elem); // 构造一个新节点，其数据部分为x，指针指向头指针
    elem = tmp; // 栈顶指针指向新节点
}

elemType pop() {
    node *tmp = elem; // 指针指向栈顶
    elemType x = tmp->data; // 将栈顶元素赋给x
    elem = elem->next; // 栈顶指针后移
    delete tmp; // 释放表头节点
    return x;
}
```

### 链接栈的性能分析

由于所有的操作都是对栈顶的操作，与栈中的元素个数无关。所以，所有运算的时间复杂度都是O（1）

## 递归

递归是一种特殊的函数调用，是在一个函数中又调用了函数本身。在系统内部，函数调用是用**系统栈**来实现。

### 函数调用过程

函数调用是通过栈实现的

#### 函数执行过程
```c
void main() {
    …
    r1: f1();
    r2: …
}

void f1() {
    …
    t1: f2();
    t2: …
}

void f2() {
    …
    …
}
```

### 函数调用的实现

设置一个栈模拟函数调用。当发生函数调用时，将当前的函数的现场进栈。

调用f1后：Top r2  
调用f2后：Top r2 t2  
返回f1后：Top r2  
返回main后：Top

### 打印正整数的递归函数
```c
// 以十进制打印非负整数num
void printInt(int num) {
    if (num < 10) // 递归终止条件
        cout.put(num + '0'); // 打印一个字符的函数
    else {
        printInt(num/10); // 打印最后一个数之外的所有数
        cout.put(num % 10 + '0'); // 打印最后一个数
    }
}
```

例：打印1234

### 打印正整数的非递归实现

设置一个栈，记录要做的工作，即将要打印的正整数。然后不断地从栈中获取任务，完成该任务，直到完成了所有的任务即栈为空。

先将整个数进栈，然后重复下列工作，将打印一个正整数的工作分解成两个子工作，将子工作放入栈中：
- 打印十位数以上的数字
- 打印个位数字

打印正整数1234时栈的变化：
1234进栈 → 执行打印1234 → 执行打印123 → 执行打印12 → 打印1 → 打印2 → 打印3 → 打印4

```c
void PrintNum(int num) {
    linkStack <int> s;
    int tmp;
    
    s.push(num);
    while (!s.isEmpty()) {
        tmp = s.pop();
        if (tmp > 9) {
            s.push(tmp % 10);
            s.push(tmp / 10);
        }
        else cout.put(tmp + '0');
    }
}
```

### 递归函数特点

**缺点**：
- 运行效率低，无论计算时间还是占用空间都比非递归算法差

**优点**：
- 结构清晰、可读性强
- 易于用数学归纳法证明算法的正确性

**典型应用**：
- 最大连续子序列求和
- Hanoi塔问题
- Fibonacci数列

### 递归算法-Fibonacci数列

```c
int fib(int n) {
    if (n == 0) return 0;
    else if (n == 1) return 1;
    else return(fib(n-1) + fib(n-2));
}
```

**Trouble-maker**: The growth of redundant calculations is explosive.

**Solution**: Record the two most recently computed values to avoid recursive calls.

### 递归实现存在问题

T(N) ≥ T(N – 1) + T(N – 2)  
T(N) ≥ F(N)

N=40，F(40)=102,334,155, T(40)>300,000,000

### 动态规划方法

为了减少重复的递归调用，我们可以反过来计算。先计算f(2)，有了f(2)再计算f(3)，以此类推，计算到f(n)。在此过程中不需要任何递归。

引入一个数组，从小到大计算每个子问题的解，并保存在数组中

```c
int fib(int n) {
    int f0 = 0, f1 = 1, fn;
    for (int i = 2; i <= n; i++) {
        fn = f0 + f1;
        f0 = f1;
        f1 = fn;
    }
    return fn;
}
```
T(N) = O(N)

# 队列

## 队列的概念

队列是另外一种常用的线性结构，到达越早的结点，离开的时间越早。所以队列通常称之为**先进先出(FIFO: First In First Out)**队列。

例：银行储蓄柜前排队取款、IP交换机中队列及调度算法、进程管理……

### 队列的基本概念

空队 → 进队 → 出队  
队头 → 队尾

### 队列的基本操作

- **create()**：创建一个空的队列
- **enQueue(x)**：将x插入队尾，使之成为队尾元素
- **deQueue()**：删除队头元素并返回队头元素值
- **getHead()**：返回队头元素的值
- **isEmpty()**：若队列为空，返回true，否则返回false

## 队列的顺序存储

使用数组存储队列中的元素。队列中的结点个数最多为MaxSize个。元素下标的范围从0到MaxSize-1。

### 顺序队列的三种组织方式

1. **队头位置固定**：队头固定在下标0，用一个变量指出队尾位置。队列为空时队尾位置为-1。缺点：出队会引起大量的数据移动
2. **队头位置不固定**：使用队首指针front和队尾指针rear，分别指示队首结点的前一位置和队尾结点存放的下标地址，用于删除队首结点和指示到何处去排队。队列初始化时，设front = rear(都为-