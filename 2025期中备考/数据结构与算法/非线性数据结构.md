## 树
- 前,中,后序遍历的栈实现。
- clear递归实现删除所有节点
- size()递归实现统计所有节点
- height(),1+max(左子树高度，右子树高度)
- 孩子链表示法，将任意子树转为二叉树
- 双亲表示法，\[ data,parent ]，找双亲容易，找孩子难
	- 设计对应算法
- 森林
- 表达式树
	- 算术表达式可以表示为一棵二叉树，如: (4-2)* (10+(4+6)/2)+2 
	- 如图![[Pasted image 20251105165706.png]]
- 构建过程总结：顺序扫描中缀表达式 
	当扫描到的是==运算数==：先检查当前的表达式树是否存在。如果不存在，则表示扫描到的是第一个运算数，将它作为树根。如果树存在，则将此运算数作为前一运算符的==右孩子==。 
	如果扫描到的是+或-：将它作为根结点，原来的树作为它的==左子树==。n如果扫描到的是*或/：则与根结点比较。如果根结点也是*或/，则根结点应该先执行，于是将当前运算符作为根结点，原来的树作为左子树。如果根结点是+或-，则当前运算符应该先运算，于是将它作为右子树的根，原来的右子树作为它的左子树。
	在遇到运算数时，如何知道它前面的运算符是谁？这只需要判别根结点有没有右孩子。如果没有右孩子，则运算数是根结点的右运算数，否则就是根结点右孩子的右运算数。
- 字符的编码
	- 哈夫曼树
		- ![[Pasted image 20251105170151.png]]
### 树的例题
- 二叉树镜像
- 二叉树的最大深度
	- 递归取左右子树的最大高度
- 阅读代码
	-   ![[Pasted image 20251105171216.png]]
		- 答案：按二叉树中叶子结点数据自右至左链接成一个链表。
	- 以二叉链表为存储结构的二叉树，其数据域为整型，试设计算法，计算每层中结点数据域值大于50的结点个数，并输出这些结点数据域的值和序号
		- 按层次遍历，工作队列中的节点个数就是第i+1层的节点个数
			- // 初始化队列
void InitQueue(LinkQueue *Q) {
    Q->front = Q->rear = (QueueNode*)malloc(sizeof(QueueNode));
    if (!Q->front) exit(1);
    Q->front->next = NULL;
}

// 入队操作
void EnQueue(LinkQueue *Q, BiTNode *treeNode, int level) {
    QueueNode *newNode = (QueueNode*)malloc(sizeof(QueueNode));
    if (!newNode) exit(1);
    
    newNode->treeNode = treeNode;
    newNode->level = level;
    newNode->next = NULL;
    
    Q->rear->next = newNode;
    Q->rear = newNode;
}

// 出队操作
int DeQueue(LinkQueue *Q, BiTNode **treeNode, int *level) {
    if (Q->front == Q->rear) return 0;  // 队列空
    
    QueueNode *temp = Q->front->next;
    *treeNode = temp->treeNode;
    *level = temp->level;
    
    Q->front->next = temp->next;
    if (Q->rear == temp) Q->rear = Q->front;
    
    free(temp);
    return 1;
}

// 判断队列是否为空
int IsQueueEmpty(LinkQueue *Q) {
    return Q->front == Q->rear;
}

// 计算每层大于50的结点个数并输出信息
void CountNodesByLevel(BiTree T) {
    if (!T) {
        printf("二叉树为空！\n");
        return;
    }
    
    LinkQueue Q;
    InitQueue(&Q);
    
    // 根结点入队，层数为1
    EnQueue(&Q, T, 1);
    
    int currentLevel = 1;      // 当前处理的层数
    int countInLevel = 0;      // 当前层大于50的结点计数
    int nodeIndex = 1;         // 全局结点序号（按层次遍历顺序）
    
    printf("=== 各层数据域值大于50的结点信息 ===\n");
    
    while (!IsQueueEmpty(&Q)) {
        BiTNode *currentNode;
        int level;
        DeQueue(&Q, &currentNode, &level);
        
        // 如果进入新的一层，输出上一层的统计结果
        if (level > currentLevel) {
            if (countInLevel > 0) {
                printf("第%d层共有 %d 个结点数据域值大于50\n", 
                       currentLevel, countInLevel);
            } else {
                printf("第%d层没有结点数据域值大于50\n", currentLevel);
            }
            printf("----------------------------------------\n");
            currentLevel = level;
            countInLevel = 0;
        }
        
        // 处理当前结点
        if (currentNode->data > 50) {
            countInLevel++;
            printf("层数: %d, 序号: %d, 数据值: %d\n", 
                   level, nodeIndex, currentNode->data);
        }
        
        // 左右孩子入队
        if (currentNode->lchild) {
            EnQueue(&Q, currentNode->lchild, level + 1);
        }
        if (currentNode->rchild) {
            EnQueue(&Q, currentNode->rchild, level + 1);
        }
        
        nodeIndex++;
    }
    
    // 输出最后一层的统计结果
    if (countInLevel > 0) {
        printf("第%d层共有 %d 个结点数据域值大于50\n", 
               currentLevel, countInLevel);
    } else {
        printf("第%d层没有结点数据域值大于50\n", currentLevel);
    }
    
    // 释放队列头结点
    free(Q.front);
}


