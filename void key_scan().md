![[key_scan.png]]
# 代码问题
## 没有实现消除抖动

修改思路
下面这段代码主要做了两件事：  
1. 读 4 个按键（B1~B4）的当前电平；  
2. 当检测到“由高→低”的下降沿时，点亮对应 LED，并把当前状态缓存到 Bx_next_state 以备下次比较。

可以优化的点集中在“重复代码多、可读性差、扩展性弱”。下面给出几种常见写法，按“侵入性”从低到高排列，你可以根据项目规模、个人习惯、硬件资源自由取舍。

------------------------------------------------
一、最小改动——宏/函数消除重复
把“读引脚+状态缓存+沿检测+点灯”封装成一个带参数的小函数（或宏），主循环里一行代码搞定：

```c
/* 1. 引脚定义 ----------------------------------------------------*/
typedef struct {
    GPIO_TypeDef *port;
    uint16_t      pin;
    uint8_t       led_idx;
} KeyPin_t;

static const KeyPin_t key_tbl[4] = {
    {GPIOB, GPIO_PIN_0, 1},
    {GPIOB, GPIO_PIN_1, 2},
    {GPIOA, GPIO_PIN_0, 3},
    {GPIOB, GPIO_PIN_2, 4},
};

/* 2. 状态缓存 ----------------------------------------------------*/
static uint8_t key_last[4] = {1,1,1,1};   // 默认上拉高电平

/* 3. 按键扫描函数 -----------------------------------------------*/
static void key_scan(void)
{
    for (uint8_t i = 0; i < 4; i++) {
        uint8_t cur = HAL_GPIO_ReadPin(key_tbl[i].port, key_tbl[i].pin);
        if (cur == 0 && key_last[i] == 1)          // 下降沿
            led_show(key_tbl[i].led_idx, 1);       // 点亮
        key_last[i] = cur;                         // 缓存
    }
}

/* 4. 主循环 ------------------------------------------------------*/
while (1) {
    key_scan();        // 一行搞定
}
```

优点  
- 代码量骤降，新增按键只需往 `key_tbl` 里再加一行，无需改逻辑。  
- 状态变量只有 4 字节，RAM 占用反而更小。  

缺点  
- 多了个查表循环，时间开销可忽略（4 次循环 vs 原来 4 次 if）。  

------------------------------------------------
二、再进一步——状态机/事件法
如果后续要支持“长按、双击、连击”等复杂场景，可以把沿检测做成“事件”：

```c
typedef enum {
    KEY_EV_NONE  = 0,
    KEY_EV_DOWN  = 1,
    KEY_EV_UP    = 2,
    KEY_EV_LONG  = 3,
} KeyEvent_t;

KeyEvent_t key_event_get(uint8_t idx);   // 底层状态机实现
```

主循环只处理事件，逻辑与硬件彻底解耦：

```c
for (uint8_t i = 0; i < 4; i++) {
    if (key_event_get(i) == KEY_EV_DOWN)
        led_show(i+1, 1);
}
```

------------------------------------------------
三、终极抽象——软件分层
把“按键驱动”单独做成一个模块（key.c/key.h），对外只提供：

```c
bool key_triggered(uint8_t id);   // 本次扫描是否刚按下
```

`main.c` 里就只剩业务：

```c
if (key_triggered(1)) led_show(1,1);
if (key_triggered(2)) led_show(2,1);
...
```

------------------------------------------------
四、小结
1. 先消灭“复制粘贴”——用数组+循环/查表最省事；  
2. 再把“沿检测”封装成函数/事件，主循环只关心业务；  
3. 如果项目大，继续拆成“驱动层→逻辑层→应用层”，后续加按键、改电平、换 MCU 都不用动上层代码。

按上面第一步改，就能把原来 20 多行代码压到 5 行以内，同时可读性、可维护性、可扩展性全部提升。