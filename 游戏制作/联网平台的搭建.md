请求，客户端->服务端
![[Pasted image 20250709161056.png]]
从post的body请求体中获取
状态
![[Pasted image 20250709161249.png]]
响应，服务端->客户端
[[回调函数]]
## 需求分析
需要传递并更新map，now_type.
客户端->服务端
胜负判断，only in服务端
lambda函数？
序列化

反序列化
避免多个服务端同时访问客户端
->std::mutex

```c++
#include<mutex>
#include<fstream>

std::mutex g_mutex //全局互斥锁

int log_1 = -1;//玩家1登录状态
int log_2 = -1;//玩家2登录状态

void on_hello(const http::REquest& req, http::Response& res)//req存储请求数据，res存储响应数据
{
	std::lock_guard<std::mutex> lock(g_mutex);
	std::cout << "hello from Client!" << std::endl;
	res.set_content();//修改Response
}



sever.Post("/hello",on_hello);

sever.listen("localhost",25565);

return 0;

```


```c++
g_mutex.lock();

g_mutex.unlock();
```
避免遗漏
对象在实例化时会调用其构造函数，
被删除时调用析构函数。
只要构建一个对象，可以执行，
std::lock_guard类
```c++
#include<mutex>
#include<fstream>

std::mutex g_mutex //全局互斥锁

int log_1 = -1;//玩家1登录状态
int log_2 = -1;//玩家2登录状态

sever.Post("/login",[&](const httplib::Request& req,hrrplib::Response& res ))
```